package com;

import java.util.*;

public class NewSolution {

    public static void main(String[] args) {
//        System.out.println(new NewSolution().maxProfit(new int[]{7, 1, 5, 3, 6, 4}));
//        System.out.println(new NewSolution().maxProfit(new int[]{0, 1, 5, 3, 6, 4}));
//        System.out.println(new NewSolution().maxProfit(new int[]{0, 6, -3, 7}));
//
//        System.out.println(new NewSolution().maxProfitBruteForce(new int[]{7, 1, 5, 3, 6, 4}));
//        System.out.println(new NewSolution().maxProfitBruteForce(new int[]{0, 1, 5, 3, 6, 4}));
//        System.out.println(new NewSolution().maxProfitBruteForce(new int[]{0, 6, -3, 7}));

//        System.out.println(new NewSolution().maxSubArray(new int[]{-2,1,-3,4,-1,2,1,-5,4}));
//        System.out.println(new NewSolution().maxSubArray(new int[]{-2,-1,-5}));

//        System.out.println(new NewSolution().findShortestSubArray(new int[]{1, 2, 2, 3, 1}));
//        System.out.println(new NewSolution().findShortestSubArray(new int[]{1}));

//        System.out.println(new NewSolution().maxProduct(new int[]{-2, 3, -2, 4}));
//        System.out.println(new NewSolution().maxProduct(new int[]{-2, 0, -1}));
//        System.out.println(new NewSolution().maxProduct(new int[]{0, 2}));
//        System.out.println(new NewSolution().maxProduct(new int[]{-2, 3, 0, -4, -20}));

//        new NewSolution().findDisappearedNumbers(new int[]{4, 3, 2, 7, 8, 2, 3, 1}).forEach(r -> System.out.print(r + " "));

//        new NewSolution().findDuplicates(new int[]{4, 3, 2, 7, 8, 2, 3, 1}).forEach(r -> System.out.print(r + " "));
//        new NewSolution().findDuplicates(new int[]{10, 2, 5, 10, 9, 1, 1, 4, 3, 7}).forEach(r -> System.out.print(r + " "));

//        System.out.println(new NewSolution().isToeplitzMatrix(new int[][]{new int[]{1, 2, 3, 4}, new int[]{5, 1, 2, 3}, new int[]{9, 5, 1, 2}}));

//        System.out.println(new NewSolution().findMaxConsecutiveOnes(new int[]{1, 1, 0, 1, 1, 1,0}));

//        System.out.println(new NewSolution().isToeplitzMatrix(new int[][]{new int[]{1, 0, 0, 1}, new int[]{1, 0, 0, 1}, new int[]{0, 0, 1, 1}}));

//        System.out.println(new NewSolution().maxAreaOfIsland(new int[][]{new int[]{1, 0, 0, 1}, new int[]{1, 0, 0, 1}, new int[]{0, 0, 1, 1}}));

//        System.out.println(new NewSolution().islandPerimeter(new int[][]{new int[]{0, 1, 0, 0}, new int[]{1, 1, 1, 0}, new int[]{0, 1, 0, 0}, new int[]{1, 1, 0, 0}}));

//        System.out.println(new NewSolution().findUnsortedSubarray(new int[]{2, 6, 4, 8, 10, 9, 15}));
//        System.out.println(new NewSolution().findUnsortedSubarray(new int[]{1, 2, 3, 4}));

//        System.out.println(new NewSolution().jump(new int[]{2, 3, 1, 1, 4})==2);
//        System.out.println(new NewSolution().jump(new int[]{2, 3, 1, 1, 4, 1, 1, 1, 1, 1}));
//        System.out.println(new NewSolution().jump(new int[]{1, 2}) == 1);
//        System.out.println(new NewSolution().jump(new int[]{3, 2, 1}) == 1);
//        System.out.println(new NewSolution().jump(new int[]{4, 1, 1, 3, 1, 1, 1})==2);
//        System.out.println(new NewSolution().leastInterval(new char[]{'A', 'A', 'A', 'B', 'B', 'B'}, 0));
//        System.out.println(new NewSolution().subarraySum(new int[]{100, 1, 2, 3, 4}, 6) == 1);
//        System.out.println(new NewSolution().subarraySum(new int[]{1, 1, 1}, 2) == 2);
//        System.out.println(new NewSolution().subarraySum(new int[]{1, 1, 1}, 0) == 0);
//        System.out.println(new NewSolution().subarraySum(new int[]{1}, 1) == 1);
//        System.out.println(new NewSolution().subarraySum(new int[]{1, 2, 354, 3}, 1) == 1);
//        System.out.println(new NewSolution().pivotIndex(new int[]{1, 7, 3, 6, 5, 6}) == 3);
//        System.out.println(new NewSolution().pivotIndex(new int[]{1, 2, 3}) == -1);
//        System.out.println(new NewSolution().pivotIndex(new int[]{1, 2, 2, 3}) == 2);
//        System.out.println(new NewSolution().pivotIndex(new int[]{-1, -1, -1, -1, -1, 0}) == 2);
//        new NewSolution().merge(new int[]{1, 2, 10, 0, 0, 0}, 3, new int[]{-1, 5, 6}, 3);
//        System.out.println(new NewSolution().findDuplicate(new int[]{1, 3, 4, 2, 2}) == 2);
//        System.out.println(new NewSolution().findDuplicate(new int[]{3, 1, 3, 4, 2}) == 3);
//        System.out.println(new NewSolution().partitionLabels2("ababcbacadefegdehijhklij"));
//        System.out.println(new NewSolution().partitionLabels2("a"));
        //[1,3],[2,6],[8,10],[15,18]
//        System.out.println(new NewSolution().merge(Arrays.asList(new Interval(1, 3), new Interval(2, 6), new Interval(8, 10), new Interval(15, 18))));
//        System.out.println(new NewSolution().merge(Arrays.asList(new Interval(1, 4), new Interval(4, 5))));
//        System.out.println(new NewSolution().merge(Arrays.asList(new Interval(1, 4), new Interval(2, 3))));
//        System.out.println(new NewSolution().merge(new ArrayList<>()));
//        System.out.println(new NewSolution().maxArea(new int[]{1, 3, 3, 3, 1}));
//        System.out.println(new NewSolution().trap(new int[]{}) == 0);
//        System.out.println(new NewSolution().trap(new int[]{0, 4, 4, 3}) == 0);
//        System.out.println(new NewSolution().trap(new int[]{0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1}) == 6);
//        System.out.println(new NewSolution().dailyTemperatures(new int[]{73, 74, 75, 71, 69, 72, 76, 73}));
//        System.out.println(new NewSolution().dominantIndex(new int[]{3, 6}));
//        System.out.println(new NewSolution().dominantIndex(new int[]{1,2,3,4}));
//        System.out.println(new NewSolution().dominantIndex(new int[]{1}));
//        System.out.println(new NewSolution().dominantIndex(new int[]{0,0,3,2}));
//        new NewSolution().plusOne(new int[]{0});
//        new NewSolution().plusOne(new int[]{3, 2});
//        new NewSolution().plusOne(new int[]{1, 9, 9, 9});
//        new NewSolution().plusOne(new int[]{8, 9, 9});
//        new NewSolution().spiralOrder(new int[][]{
//                new int[]{1, 2, 3, 4},
//                new int[]{5, 6, 7, 8},
//                new int[]{9, 10, 11, 12},
//                new int[]{13,14,15,16},
//        });
//        System.out.println();
//        new NewSolution().spiralOrder(new int[][]{
//                new int[]{1, 2, 3, 4},
//        });

//        new NewSolution().findDiagonalOrder(new int[][]{
//                new int[]{1, 2, 3, 4},
//                new int[]{5, 6, 7, 8},
//                new int[]{9, 10, 11, 12},
//                new int[]{13,14,15,16},
//        });
//        System.out.println();
//        new NewSolution().findDiagonalOrder(new int[][]{
//                new int[]{1, 2, 3, 4},
//        });
//        new NewSolution().generate(1);
//        System.out.println(new NewSolution().addBinary("1", "111111"));
//        System.out.println(new NewSolution().addBinary("1010", "1011"));
//        System.out.println(new NewSolution().strStr("1aaa", "aaa"));
//        System.out.println(new NewSolution().strStr("mississippi", "issip"));
//        System.out.println(new NewSolution().longestCommonPrefix(new String[]{"cog", "cacecar", "car"}));
//        System.out.println(new NewSolution().longestCommonPrefix(new String[]{"flower", "f", "flight"}));
//        System.out.println(new NewSolution().longestCommonPrefix(new String[]{"a", "aca", "accb", "b"}));
//        System.out.println(new NewSolution().rotLeft(new int[]{1, 2, 3, 4, 5}, 5));
//        System.out.println(new NewSolution().minimumSwaps(new int[]{1, 3, 5, 2, 4, 6, 8,100,98}) );
//        System.out.println(new NewSolution().minimumSwaps(new int[]{2, 3, 4, 1, 5}) == 3);
//        System.out.println(new NewSolution().minimumSwaps(new int[]{4, 3, 1, 2}) == 3);
//        System.out.println(new NewSolution().minSubArrayLen(213, new int[]{12,28,83,4,25,26,25,2,25,25,25,12}));
//        System.out.println(new NewSolution().minSubArrayLen(7, new int[]{2,3,1,2,4,3}));
//        System.out.println(new NewSolution().minSubArrayLen(3, new int[]{1,1}));
//        System.out.println(new NewSolution().getRow(0));
//        new NewSolution().minimumBribes(new int[]{2, 1, 5, 3, 4});
//        new NewSolution().minimumBribes(new int[]{2, 1, 5, 3, 4});
//        new NewSolution().minimumBribes(new int[]{2, 5, 1, 3, 4});
//        new NewSolution().minimumBribes(new int[]{1, 2, 5, 3, 7, 8, 6, 4});
//        new NewSolution().gamingArray(new int[]{5, 2, 6, 3, 4});
//        new NewSolution().gamingArray(new int[]{3, 1});
//        new NewSolution().gamingArray(new int[]{1, 2, 3, 4});
//        new NewSolution().gamingArray(new int[]{4, 3, 2, 1});
//        System.out.println(new NewSolution().robotSim(new int[]{4,-1,4,-2,4}, new int[][]{new int[]{2,4}}));
//        System.out.println(new NewSolution().minEatingSpeed(new int[]{30, 11, 23, 4, 20}, 6));
//        System.out.println(new NewSolution().letterCasePermutation("a1b2"));
//        System.out.println(new NewSolution().letterCasePermutation(""));
//        System.out.println(new NewSolution().countArrangement(2));
//        System.out.println(new NewSolution().countArrangement(3));
//        System.out.println(new NewSolution().subsets(new int[]{1, 2, 3}));
//        System.out.println(new NewSolution().permuteUnique(new int[]{1,1,2}));
//        System.out.println(new NewSolution().minEatingSpeed(new int[]{30, 11, 23, 4, 20}, 6));
//        System.out.println(new NewSolution().minEatingSpeed(new int[]{30, 11, 23, 4, 20,22}, 5));
//        System.out.println(new NewSolution().isNStraightHand(new int[]{1, 2, 3, 6, 2, 3, 4, 7, 8,9}, 2));
//        System.out.println(new NewSolution().isNStraightHand(new int[]{1,3}, 2));
//        System.out.println(new NewSolution().scoreOfParentheses(""));
//        System.out.println(new NewSolution().countBits(5));
//        System.out.println(new NewSolution().longestSubstring("aaacbbba", 3));
//        System.out.println(new NewSolution().longestSubstring("abcabcabc", 3));//3
//        System.out.println(new NewSolution().longestSubstring("abcabcab", 3));//0
//        System.out.println(new NewSolution().increasingTriplet(new int[]{1,2,3,4,5}));
//        System.out.println(new NewSolution().increasingTriplet(new int[]{5,4,3,2,1}));
//        new NewSolution().wiggleSort(new int[]{1, 5, 1, 1, 6, 4}); //1,1,1,4,5,6
//        new NewSolution().wiggleSort(new int[]{1, 3, 2, 2, 3, 1,10}); //1,1,2,2,3,3,10
//        new NewSolution().wiggleSort(new int[]{1, 2, 2, 1, 2, 1, 1, 1, 1, 2, 2, 2}); //1,1,2,2,3,3,10
//        System.out.println(new NewSolution().calculate(" 10*3+55 / 2  ")); //1,1,2,2,3,3,10
//        System.out.println(new NewSolution().calculate("3+2*2")); //1,1,2,2,3,3,10
//        System.out.println(new NewSolution().calculate("0-2147483647")); //1,1,2,2,3,3,10
//        System.out.println(new NewSolution().calculate("1-1+1")); //1,1,2,2,3,3,10
//        System.out.println(new NewSolution().arrayNesting(new int[]{5,4,0,3,1,6,2}));
//        System.out.println(new NewSolution().numRescueBoats(new int[]{2, 2, 2, 1}, 3));
//        System.out.println(new NewSolution().checkInclusion("ab", "eidbaooo"));
//        System.out.println(new NewSolution().checkInclusion("ab", "eidboaoo"));
//        System.out.println(new NewSolution().checkInclusion("adc", "dcda"));
//        System.out.println(new NewSolution().findAnagrams("cbaebabacd", "abc"));
//        System.out.println(new NewSolution().findAnagrams("abab", "ab"));
//        System.out.println(new NewSolution().findAnagrams("baa", "aa"));


//        System.out.println(new NewSolution().possibleBipartition(4, new int[][]{
//                new int[]{1, 2},
//                new int[]{1, 3},
//                new int[]{2, 4},
//        }));
//        System.out.println(new NewSolution().possibleBipartition(3, new int[][]{
//                new int[]{1, 2},
//                new int[]{1, 3},
//                new int[]{2, 3},
//        }));
//        System.out.println(new NewSolution().possibleBipartition(1, new int[][]{
//        }));
//        new NewSolution().spiralMatrixIII(1,4,0,0);
//        new NewSolution().spiralMatrixIII(5, 6, 1, 4);
//        System.out.println(new NewSolution().decodeAtIndex("leet2code3", 10));
//        System.out.println(new NewSolution().decodeAtIndex("a2345678999999999999999", 1));
//        System.out.println(new NewSolution().decodeString("3[a2[c]]"));
//        System.out.println(new NewSolution().decodeString("2[abc]3[cd]ef"));
//        System.out.println(new NewSolution().findKthLargest(new int[]{3, 2, 7, 1, 5, 6, 4}, 2));
//        System.out.println(new NewSolution().isRectangleOverlap(new int[]{0,0,2,2}, new int[]{1,1,3,3}));
        System.out.println(Arrays.asList(new NewSolution().constructFromPrePost(
                new int[]{3,4,1,2},
                new int[]{1,4,2,3})));
//        System.out.println(Arrays.asList(new NewSolution().constructFromPrePost(
//                new int[]{1,2,4,5,3,6,7},
//                new int[]{4,5,2,6,7,3,1})));
    }
    public TreeNode constructFromPrePost(int[] pre, int[] post) {
        TreeNode treeNode = constructFromPrePostHelper(pre, post, 0, pre.length - 1, new int[]{0});
//        inorder(treeNode);
        return treeNode;
    }
    private TreeNode constructFromPrePostHelper(int[] pre, int[] post, int l, int h,int[] preIndex) {
        if(preIndex[0]>=pre.length || l > h) return null;
        TreeNode root = new TreeNode(pre[preIndex[0]]);
        preIndex[0]++;
        if (l == h || preIndex[0] >= pre.length)
            return root;
        int i;

        for (i = l; i <= h; i++)
        {
            if (post[i] == pre[preIndex[0]])
                break;
        }
        if (i <= h)
        {
            root.left = constructFromPrePostHelper(pre, post, l, i, preIndex);
            root.right = constructFromPrePostHelper(pre, post, i + 1, h, preIndex);
        }
        return root;

    }
    public static class TreeNode {
        int val;
        TreeNode left;
        TreeNode right;
        TreeNode(int x) { val = x; }
    }

    private void inorder(TreeNode treeNode) {
        if(treeNode==null) return;
        inorder(treeNode.left);
        System.out.print(treeNode.val+" ");
        inorder(treeNode.right);
    }
    //https://leetcode.com/problems/rectangle-overlap/description/
    public boolean isRectangleOverlap(int[] rec1, int[] rec2) {
        return false;
    }

    //https://leetcode.com/problems/kth-largest-element-in-an-array/description/
    //TODO
    public int findKthLargest(int[] nums, int k) {
        k = nums.length - k;
        int lo = 0;
        int hi = nums.length - 1;
        while (lo < hi) {
            final int j = partition(nums, lo, hi);
            if (j < k) {
                lo = j + 1;
            } else if (j > k) {
                hi = j - 1;
            } else {
                break;
            }
        }
        return nums[k];
    }

    private int partition(int[] a, int lo, int hi) {
        int i = lo;
        int j = hi + 1;
        while (true) {
            while (i < hi && less(a[++i], a[lo])) ;
            while (j > lo && less(a[lo], a[--j])) ;
            if (i >= j) {
                break;
            }
            exch(a, i, j);
        }
        exch(a, lo, j);
        return j;
    }

    //https://leetcode.com/problems/decode-string/description/
    public String decodeString(String s) {
       return null;
    }

    //https://leetcode.com/problems/decoded-string-at-index/description/
        public String decodeAtIndex(String S, int K) {
            long size = 0;
            for (int i = 0; i < S.length(); i++) {
                char c = S.charAt(i);
                if (Character.isDigit(c)) {
                    size *= (c - '0');
                } else {
                    size++;
                }
            }

            for (int i = S.length() - 1; i >= 0; i--) {
                char c = S.charAt(i);
                K%= size;
                if (K == 0 && Character.isLetter(c)) {
                    return String.valueOf(S.charAt(i));
                }
                if (Character.isDigit(c)) {
                    size /= (c - '0');
                } else {
                    size--;
                }
            }
            return null;
        }

    //https://leetcode.com/problems/spiral-matrix-iii/description/
    //[[1,4],[1,5],[2,5],[2,4],[2,3],[1,3],[0,3],[0,4],[0,5],[3,5],[3,4],[3,3],[3,2],[2,2],[1,2],[0,2],[4,5],[4,4],[4,3],[4,2],[4,1],[3,1],[2,1],[1,1],[0,1],[4,0],[3,0],[2,0],[1,0],[0,0]]
    public int[][] spiralMatrixIII(int R, int C, int r0, int c0) {
        int max = Math.max(R, C);
        int row = r0;
        int col = c0;
        List<int[]> res = new ArrayList<>();
        res.add(new int[]{r0, c0});
        int K = 0;
        for (int i = 1; i <= max && res.size() < R * C; i++) {
            for (int j = 0; j <= K; j++) {
                spiralMatrixIIIAdd(res, row, ++col, R, C);
            }
            for (int j = 0; j <= K; j++) {
                spiralMatrixIIIAdd(res, ++row, col, R, C);
            }
            K++;
            for (int j = 0; j <= K; j++) {
                spiralMatrixIIIAdd(res, row, --col, R, C);
            }
            for (int j = 0; j <= K; j++) {
                spiralMatrixIIIAdd(res, --row, col, R, C);
            }
            K++;
        }
        return res.toArray(new int[res.size()][2]);
    }

    void spiralMatrixIIIAdd(List<int[]> res, int rowStart, int colStart, int r, int c) {
        if (rowStart <= r - 1 && colStart <= c - 1 && rowStart >= 0 && colStart >= 0) {
            res.add(new int[]{rowStart, colStart});
        }
    }


    public boolean possibleBipartition(int N, int[][] dislikes) {
        if (dislikes.length == 0) return true;
        Map<Integer, List<Integer>> map = new LinkedHashMap<>();
        for (int i = 0; i < dislikes.length; i++) {
            int num = dislikes[i][0];
            if (map.get(num) == null) map.put(num, new ArrayList<>());
            map.get(num).add(dislikes[i][1]);
        }
        boolean[] marked = new boolean[N + 1];
        Set<Integer> set = new HashSet<>();
        for (int i = 1; i <= N; i++) {
            if (marked[i]) continue;
            boolean[] possible = {true};
            visit(i, set, map, marked, possible);
            if (!possible[0]) return false;
        }
        return true;
    }

    private void visit(int num, Set<Integer> set, Map<Integer, List<Integer>> map, boolean[] marked, boolean[] res) {
        if (set.contains(num)) {
            res[0] = false;
            return;
        }
        set.add(num);
        marked[num] = true;
        for (Integer n : map.getOrDefault(num, new ArrayList<>())) {
            visit(n, set, map, marked, res);

        }
    }

    class Count {
        StringBuilder sb = new StringBuilder();
        int count;
        int start;

        public Count(int count, int start) {
            this.count = count;
            this.start = start;
        }
    }




    private void exch(int[] a, int i, int j) {
        final int tmp = a[i];
        a[i] = a[j];
        a[j] = tmp;
    }

    private boolean less(int v, int w) {
        return v < w;
    }

    public void connect(TreeLinkNode root) {
        TreeLinkNode vertical = root;
        while (vertical != null) {
            TreeLinkNode horizontal = vertical;
            TreeLinkNode prev = horizontal;
            while (horizontal != null) {
                if (horizontal.left != null && horizontal.right != null) {
                    prev.next = horizontal.right;
                    prev = prev.next;
                }
                if (horizontal.right != null && horizontal.next != null) {
                    if (horizontal.next.left != null) {
                        prev.next = horizontal.next.left;
                        prev = prev.next;
                    }
                    if (horizontal.next.right != null) {
                        prev.next = horizontal.next.right;
                        prev = prev.next;
                    }
                }
                horizontal = horizontal.next;
            }
            vertical = vertical.left;
        }
    }

    //https://leetcode.com/problems/find-all-anagrams-in-a-string/description/
    public List<Integer> findAnagrams(String s, String p) {
        List<Integer> res = new ArrayList<>();
        if (s.length() < p.length()) return res;
        int[] counts = new int[26];
        for (int i = 0; i < p.length(); i++) {
            counts[p.charAt(i) - 'a']++;
            counts[s.charAt(i) - 'a']--;
        }
        int start = 0;
        for (int i = p.length(); i < s.length() && start < s.length(); i++) {
            if (findAnagramsValid(counts)) {
                res.add(start);
            }
            counts[s.charAt(i) - 'a']--;
            counts[s.charAt(start++) - 'a']++;
        }
        if (findAnagramsValid(counts)) {
            res.add(start);
        }
        return res;
    }

    private boolean findAnagramsValid(int[] counts) {
        for (int i = 0; i < counts.length; i++) {
            if (counts[i] != 0) return false;
        }
        return true;
    }

    //https://leetcode.com/problems/permutation-in-string/description/
    public boolean checkInclusion(String s1, String s2) {
        if (s1.length() > s2.length()) return false;
        int[] counts = new int[26];
        for (int i = 0; i < s1.length(); i++) {
            counts[s1.charAt(i) - 'a']++;
            counts[s2.charAt(i) - 'a']--;
        }

        for (int i = s1.length(); i < s2.length(); i++) {
            if (isMatch(counts)) return true;
            counts[s2.charAt(i) - 'a']--;
            counts[s2.charAt(i - s1.length()) - 'a']++;
        }
        return isMatch(counts);
    }

    private boolean isMatch(int[] counts) {
        for (int i = 0; i < 26; i++) {
            if (counts[i] != 0) return false;
        }
        return true;
    }

    public int numRescueBoats(int[] people, int limit) {
        Arrays.sort(people);
        int i = 0;
        int j = people.length - 1;
        int res = 0;
        while (i <= j) {
            if (people[i] + people[j] <= limit) {
                i++;
            }
            j--;
            res++;
        }
        return res;
    }

    public List<Integer> topKFrequent(int[] nums, int k) {
        Map<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            map.put(nums[i], map.getOrDefault(nums[i], 0) + 1);
        }
        List[] counts = new ArrayList[nums.length + 1];
        for (Integer key : map.keySet()) {
            int freq = map.get(key);
            if (counts[freq] == null) counts[freq] = new ArrayList();
            counts[freq].add(key);
        }
        List<Integer> res = new ArrayList<>();
        for (int i = counts.length - 1; i >= 0 && k > 0; i--) {
            if (counts[i] == null) continue;
            Integer min = Math.min(k, counts[i].size());
            res.addAll(counts[i].subList(0, min));
            k -= counts[i].size();
        }
        return res;
    }

    //https://leetcode.com/problems/array-nesting/description/
    public int arrayNesting(int[] nums) {
        int max = 0;
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] == Integer.MAX_VALUE) continue;
            int prev = nums[i];
            int c = 1;
            while (c < nums.length) {
                int num = nums[prev];
                if (nums[i] == num || num == Integer.MAX_VALUE) {
                    break;
                }
                nums[prev] = Integer.MAX_VALUE;
                prev = num;
                c++;
            }
            max = Math.max(max, c);
            if (max == nums.length) break;
        }
        return max;
    }

    //if its empty
    //what if its sorted/unsorted
    //what if its acending/descending order
    //2 strings, oneis longer than the other and vice versa
    //does the int array include negative numbers

    //https://leetcode.com/problems/basic-calculator-ii/description/
    public int calculate(String s) {
        LinkedList<String> q = new LinkedList<>();
        int c = 0;
        while (c < s.length()) {
            if (s.charAt(c) == ' ') {
                c++;
                continue;
            }
            if (Character.isDigit(s.charAt(c))) {
                String num = "";
                while (c < s.length() && Character.isDigit(s.charAt(c))) {
                    num += s.charAt(c);
                    c++;
                }
                if (q.size() > 1 && (q.getLast().equals("*") || q.getLast().equals("/"))) {
                    String operator = q.pop();
                    String res = eval(num, operator, q.pop());
                    q.add(res);
                } else {
                    q.add(num);
                }
            } else {
                q.add("" + s.charAt(c++));
            }
        }
        while (q.size() > 1) {
            String n1 = q.pollFirst();
            String operator = q.pollFirst();
            String eval = eval(q.pollFirst(), operator, n1);
            q.addFirst(eval);
        }
        return Integer.valueOf(q.pop());
    }

    private String eval(String n2, String operator, String n1) {
        if (operator.equals("*")) {
            return String.valueOf(Integer.parseInt(n1) * Integer.parseInt(n2));
        }
        if (operator.equals("/")) {
            return String.valueOf(Integer.parseInt(n1) / Integer.parseInt(n2));
        }
        if (operator.equals("+")) {
            return String.valueOf(Integer.parseInt(n1) + Integer.parseInt(n2));
        }
        return String.valueOf(Integer.parseInt(n1) - Integer.parseInt(n2));
    }

    //https://leetcode.com/problems/wiggle-sort-ii/description/
    //https://leetcode.com/problems/wiggle-sort-ii/discuss/77684/Summary-of-the-various-solutions-to-Wiggle-Sort-for-your-reference
    //https://leetcode.com/problems/wiggle-sort-ii/discuss/77682/Step-by-step-explanation-of-index-mapping-in-Java
    public void wiggleSort(int[] nums) {
        for (int i = 0; i < nums.length - 1; i++) {
            if (i % 2 == 0 && nums[i + 1] <= nums[i]) {
                int j = i;
                while (i < nums.length && nums[i] >= nums[j]) {
                    j++;
                }
                swap(nums, i, j);
            } else if (i % 2 == 1 && nums[i + 1] >= nums[i]) {
                int j = i;
                while (i < nums.length && nums[i] <= nums[j]) {
                    j++;
                }
                swap(nums, i, j);
            }
        }
        for (int i = 0; i < nums.length; i++) {
            System.out.print(nums[i] + " ");
        }
        System.out.println();
    }

    //https://leetcode.com/problems/increasing-triplet-subsequence/description/
    public boolean increasingTriplet(int[] nums) {
        int small = Integer.MAX_VALUE;
        int big = Integer.MAX_VALUE;
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] <= small) {
                small = nums[i];
            } else if (nums[i] <= big) {
                big = nums[i];
            } else {
                return true;
            }
        }
        return false;
    }

    //TODO
    //https://leetcode.com/problems/longest-substring-with-at-least-k-repeating-characters/description/
    public int longestSubstring(String s, int k) {
        int[] counts = new int[s.length()];
        int max = 0;
        for (int i = 0; i < s.length(); i++) {
            counts[s.charAt(i) - 'a']++;
            int j;
            for (j = 0; j < counts.length; j++) {
                if (counts[i] > 0 && counts[i] < k) break;
            }

        }

        return max;
    }

    //https://leetcode.com/problems/counting-bits/description/
    public int[] countBits(int num) {
        int[] ret = new int[num + 1];
        ret[0] = 0;
        int pow = 1;
        for (int i = 1, t = 0; i <= num; i++, t++) {
            if (i == pow) {
                pow *= 2;
                t = 0;
            }
            ret[i] = ret[t] + 1;
        }
        return ret;
    }

    //https://leetcode.com/problems/score-of-parentheses/description/
    public int scoreOfParentheses(String S) {
        return 0;
    }

    //https://leetcode.com/problems/hand-of-straights/description/
    //hand = [1,2,3,6,2,3,4,7,8], W = 3 => [1,2,3],[2,3,4],[6,7,8]
    public boolean isNStraightHand(int[] hand, int W) {
        TreeMap<Integer, Integer> map = new TreeMap<>();
        for (int i = 0; i < hand.length; i++) {
            map.put(hand[i], map.getOrDefault(hand[i], 0) + 1);
        }
        while (!map.isEmpty()) {
            int first = map.firstKey();
            for (int i = first; i < first + W; i++) {
                if (!map.containsKey(i)) return false;
                map.put(i, map.get(i) - 1);
                if (map.get(i) <= 0) map.remove(i);
            }

        }
        return true;
    }

    //https://leetcode.com/problems/keys-and-rooms/description/
    public boolean canVisitAllRooms(List<List<Integer>> rooms) {
        boolean[] visited = new boolean[rooms.size()];
        int[] total = new int[1];
        canVisitAllRoomsDfs(rooms, visited, 0, total);
        return rooms.size() == total[0];
    }

    private void canVisitAllRoomsDfs(List<List<Integer>> rooms, boolean[] visited, int curr, int[] total) {
        List<Integer> room = rooms.get(curr);
        visited[curr] = true;
        total[0]++;
        for (int nextRoom : room) {
            if (!visited[nextRoom]) {
                canVisitAllRoomsDfs(rooms, visited, nextRoom, total);
            }
        }
    }

    //https://leetcode.com/problems/koko-eating-bananas/description/
    //4,11,20,23,30
    public int minEatingSpeed(int[] piles, int H) {
        Arrays.sort(piles);
        int low = 0;
        int high = piles[piles.length - 1];
        while (low < high) {
            int mid = low + (high - low) / 2;
            int tmpH = 0;
            for (int i = 0; i < piles.length; i++) {
                tmpH += (piles[i] / mid + (piles[i] % mid == 0 ? 0 : 1));
            }
            if (tmpH > H) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return high;
    }

    int gamingArray(int[] arr) {
        int c = 0;
        int i;
        int max = 0;
        for (i = 0; i < arr.length; i++) {
            if (arr[i] > max) {
                max = arr[i];
                c++;
            }
        }
        String res = c % 2 == 1 ? "BOB" : "ANDY";
        System.out.println(res);
        return 0;
    }

    //https://leetcode.com/problems/permutations-ii/description/
    //[1,1,2] => [1,1,2], [1,2,1], [2,1,1]
    public List<List<Integer>> permuteUnique(int[] nums) {
        List<List<Integer>> res = new ArrayList<>();
        Arrays.sort(nums);
        permuteUniqueHelper(nums, new ArrayList(), res, 0);
        return res;
    }

    private void permuteUniqueHelper(int[] nums, ArrayList tmp, List<List<Integer>> res, int start) {
        if (tmp.size() == nums.length) {
            res.add(new ArrayList<>(tmp));
            return;
        }
        for (int i = 0; i < nums.length; i++) {

        }
    }

    //https://leetcode.com/problems/subsets-ii/description/
    //[1,2,2] => [2], [1], [1,2,2], [2,2], [1,2], []
    public List<List<Integer>> subsetsWithDup(int[] nums) {
        List<List<Integer>> res = new ArrayList<>();
        Arrays.sort(nums);
        subsetsWithDupHelper(nums, new ArrayList(), res, 0);
        return res;
    }

    private void subsetsWithDupHelper(int[] nums, ArrayList tmp, List<List<Integer>> res, int pos) {
        res.add(new ArrayList<>(tmp));
        for (int i = pos; i < nums.length; i++) {
            if (i != 0 && nums[i] == nums[i - 1] && i > pos) continue;
            tmp.add(nums[i]);
            subsetsWithDupHelper(nums, tmp, res, i + 1);
            tmp.remove(Integer.valueOf(nums[i]));
        }
    }

    //https://leetcode.com/problems/combination-sum/description/
    //[2,3,5],target=8.  [2,2,2,2],[2,3,3],[3,5]
    public List<List<Integer>> combinationSum(int[] nums, int target) {
        List<List<Integer>> res = new ArrayList<>();
        if (nums.length == 0) return res;
        Arrays.sort(nums);
        combinationSumHelper(nums, 0, new ArrayList(), target, res, 0);
        return res;
    }

    private void combinationSumHelper(int[] nums, int currSum, List<Integer> tmp, int target, List<List<Integer>> res, int start) {
        if (currSum > target) return;
        if (currSum == target) {
            res.add(new ArrayList<>(tmp));
            return;
        }

        for (int i = start; i < nums.length; i++) {
            int num = nums[i];
            if (currSum + num > target) return;
            tmp.add(num);
            combinationSumHelper(nums, currSum + num, tmp, target, res, i);
            tmp.remove(Integer.valueOf(num));
        }
    }

    /**
     * [
     * [3],
     * [1],
     * [2],
     * [1,2,3],
     * [1,3],
     * [2,3],
     * [1,2],
     * []
     * ]
     */
    public List<List<Integer>> subsets(int[] nums) {
        List<List<Integer>> res = new ArrayList<>();
        if (nums.length == 0) return res;

        subsetsHelper(nums, 0, new ArrayList(), res);
        return res;
    }

    private void subsetsHelper(int[] nums, int start, ArrayList tmp, List<List<Integer>> res) {
        res.add(new ArrayList<>(tmp));
        for (int i = start; i < nums.length; i++) {
            tmp.add(nums[start]);
            subsetsHelper(nums, i + 1, tmp, res);
            tmp.remove(Integer.valueOf(nums[start]));
        }
    }

    //https://leetcode.com/problems/beautiful-arrangement/description/
    public int countArrangement(int N) {
        int[] count = new int[1];
        int[] ar = new int[N];
        boolean[] marked = new boolean[N];
        for (int i = 0; i < N; i++) {
            ar[i] = i + 1;
        }
        countArrangementHelper(N, 1, marked, count);
        return count[0];
    }

    //https://leetcode.com/problems/subsets/description/

    private void countArrangementHelper(int N, int k, boolean[] marked, int[] count) {
        if (k - 1 == N) {
            count[0]++;
            return;
        }

        for (int i = 1; i <= N; i++) {
            if (marked[i - 1]) continue;
            if (i % k != 0 && k % i != 0) continue;
            marked[i - 1] = true;
            countArrangementHelper(N, k + 1, marked, count);
            marked[i - 1] = false;
        }
    }

    //https://leetcode.com/problems/letter-case-permutation/description/
    //["a1b2","a1B2","A1b2","A1B2"]
    public List<String> letterCasePermutation(String S) {
        List<String> res = new ArrayList<>();
        if (S == null) return res;

        letterCasePermutationHelper(S, res, 0);
        return res;
    }

    private void letterCasePermutationHelper(String s, List<String> res, int pos) {
        if (s.length() == pos) {
            res.add(s);
            return;
        }
        if (s.charAt(pos) >= '0' && s.charAt(pos) <= '9') {
            letterCasePermutationHelper(s, res, pos + 1);
            return;
        }

        char[] chars = s.toCharArray();
        chars[pos] = Character.toLowerCase(chars[pos]);
        letterCasePermutationHelper(new String(chars), res, pos + 1);

        chars = s.toCharArray();
        chars[pos] = Character.toUpperCase(chars[pos]);
        letterCasePermutationHelper(new String(chars), res, pos + 1);
    }

    public List<String> letterCasePermutation2(String S) {
        Queue<String> queue = new LinkedList<>();
        queue.add(S);
        for (int i = 0; i < S.length(); i++) {
            int size = queue.size();
            for (int j = 0; j < size; j++) {
                if (Character.isDigit(S.charAt(i))) continue;
                char[] poll = queue.poll().toCharArray();

                poll[i] = Character.toUpperCase(poll[i]);
                queue.add(new String(poll));

                poll[i] = Character.toLowerCase(poll[i]);
                queue.add(new String(poll));
            }
        }
        return new ArrayList<>(queue);
    }

    public int robotSim(int[] commands, int[][] obstacles) {
        Set<String> set = new HashSet<>();
        for (int i = 0; i < obstacles.length; i++) {
            set.add(obstacles[i][0] + " " + obstacles[i][1]);
        }
        int[][] dirs = new int[][]{new int[]{0, 1}, new int[]{1, 0}, new int[]{0, -1}, new int[]{-1, 0}};
        int direction = 0;
        int x = 0;
        int y = 0;
        int res = 0;
        for (int c : commands) {
            if (c == -1) {
                direction++;
                if (direction == 4) direction = 0;
            } else if (c == -2) {
                direction--;
                if (direction == -1) direction = 3;
            } else {
                while (c-- > 0 && !set.contains((x + dirs[direction][0]) + " " + (y + dirs[direction][1]))) {
                    x += dirs[direction][0];
                    y += dirs[direction][1];
                }
            }
            res = Math.max(x * x + y * y, res);
        }
        return res;
    }

    // Complete the minimumBribes function below.
    void minimumBribes(int[] q) {
        int swaps = 0;
        for (int i = q.length - 1; i >= 0; i--) {
            if (q[i] - (i + 1) > 2) {
                System.out.println("Too chaotic");
                return;
            }
            for (int j = Math.max(0, q[i] - 2); j < i; j++) {
                if (q[j] > q[i]) swaps++;
            }
        }
        System.out.println(swaps);
    }

    public List<Integer> getRow(int rowIndex) {
        Integer[] previous = new Integer[rowIndex + 1];
        Integer[] res = new Integer[rowIndex + 1];
        for (int i = 1; i <= rowIndex + 1; i++) {
            Integer[] tmp = previous;
            previous = res;
            res = tmp;
            for (int j = 0; j < i; j++) {
                if (j == 0 || j == i - 1) {
                    res[j] = 1;
                } else {
                    res[j] = previous[j] + previous[j - 1];
                }
            }
        }
        return Arrays.asList(res);
    }

    public void rotate(int[] nums, int k) {
        int rot = k % nums.length;
        int[] res = new int[nums.length];
        for (int i = 0; i < nums.length; i++) {
            res[i] = nums[(nums.length - rot + i) % nums.length];
        }
        for (int i = 0; i < res.length; i++) {
            nums[i] = res[i];
        }
    }

    public int minSubArrayLen(int s, int[] nums) {
        int sum = 0;
        int minSize = Integer.MAX_VALUE;
        int j = 0;
        for (int i = 0; i < nums.length; i++) {
            sum += nums[i];
            while (sum >= s) {
                minSize = Math.min(minSize, i - j + 1);
                sum -= nums[j];
                j++;
            }
        }
        return minSize == Integer.MAX_VALUE ? 0 : minSize;
    }

    int minimumSwaps2(int[] a) {
        int swap = 0;
        for (int i = 0; i < a.length; i++) {
            if (i + 1 != a[i]) {
                int t = i;
                while (a[t] != i + 1) {
                    t++;
                }
                int temp = a[t];
                a[t] = a[i];
                a[i] = temp;
                swap++;
            }
        }
        return swap;

    }

    public void swap(int[] ar, int i, int j) {
        int tmp = ar[i];
        ar[i] = ar[j];
        ar[j] = tmp;
    }

    int minimumSwaps(int[] arr) {
        int swaps = 0;
        for (int i = 0; i < arr.length; i++) {
            if (i + 1 == arr[i]) continue;
            int min = i;
            for (int j = i; j < arr.length; j++) {
                if (arr[j] == i + 1) {
                    min = j;
                    break;
                }
            }
            if (i + 1 == arr[min]) {
                swap(arr, i, min);
                swaps++;
            }
        }
        return swaps;
    }

    int[] rotLeft(int[] a, int d) {
        int[] res = new int[a.length];
        int rot = d % a.length;
        for (int i = 0; i < a.length; i++) {
            res[i] = a[(i + rot) % a.length];
        }
        return res;
    }

    public String longestCommonPrefix(String[] strs) {
        String res = "";
        if (strs.length == 0) return res;
        if (strs.length == 1) return strs[0];
        String pre = strs[0];
        int i = 1;
        while (i < strs.length) {
            while (strs[i].indexOf(pre) != 0) {
                pre = pre.substring(0, pre.length() - 1);
            }
            i++;
        }
        return pre;
    }

    public String longestCommonPrefix2(String[] strs) {
        String res = "";
        if (strs.length == 0) return res;
        if (strs.length == 1) return strs[0];
        int c = 0;
        while (true) {
            int i;
            for (i = 1; i < strs.length; i++) {
                if (strs[i - 1].length() <= c || strs[i].length() <= c || strs[i].charAt(c) != strs[i - 1].charAt(c)) {
                    break;
                }
            }
            if (i != strs.length) break;
            c++;
        }
        return strs[0].substring(0, c);
    }

    //TODO KMP Knuth-Morris-Pratt
    public int strStr(String haystack, String needle) {
        if (needle.isEmpty()) return 0;
        if (haystack.isEmpty()) return -1;
        for (int i = 0; i < haystack.length(); i++) {
            if (haystack.charAt(i) == needle.charAt(0)) {
                int j;
                for (j = 0; j < needle.length(); j++) {
                    if (i + j >= haystack.length() || haystack.charAt(i + j) != needle.charAt(j)) {
                        break;
                    }
                }
                if (j == needle.length()) return i;
            }
        }
        return -1;
    }

    // 1 and 1 and rem=0 => 0,rem =1
    // 1 and 1 and rem=1 => 1 and rem=1
    public String addBinary(String a, String b) {
        int rem = 0;
        int longest = Math.max(a.length(), b.length());
        StringBuilder sbb = new StringBuilder();
        for (int i = 0; i < longest; i++) {
            int aa = i < a.length() ? a.charAt(a.length() - 1 - i) - '0' : 0;
            int bb = i < b.length() ? b.charAt(b.length() - 1 - i) - '0' : 0;
            int sum = aa + bb + rem;
            if (sum == 3) {
                rem = 1;
                sbb.append(1);
            } else if (sum == 2) {
                rem = 1;
                sbb.append(0);
            } else {
                rem = 0;
                sbb.append(sum);
            }
        }
        if (rem != 0) sbb.append(rem);
        return sbb.reverse().toString();
    }

    public String addBinary2(String a, String b) {
        if (a.equals("0")) return b;
        if (b.equals("0")) return a;
        long aNum = binaryToNum(a);
        long bNum = binaryToNum(b);
        long sum = aNum + bNum;
        String res = "";
        while (sum > 0) {
            res = sum % 2 + res;
            sum = sum / 2;
        }
        return res;
    }

    long binaryToNum(String a) {
        long aNum = 0;
        long p = 0;
        for (int i = a.length() - 1; i >= 0; i--) {
            aNum += Integer.valueOf(String.valueOf(a.charAt(i))) * Math.pow(2, p++);
        }
        return aNum;
    }

    public List<List<Integer>> generate(int numRows) {
        List<List<Integer>> res = new ArrayList<>();
        for (int i = 1; i <= numRows; i++) {
            List<Integer> list = new ArrayList<>();
            for (int j = 0; j < i; j++) {
                if (j == 0 || j == i - 1) {
                    list.add(1);
                } else {
                    List<Integer> prev = res.get(i - 2);
                    list.add(prev.get(j - 1) + prev.get(j));
                }
            }
            res.add(list);
        }
        return res;
    }

    public int[] findDiagonalOrder(int[][] matrix) {
        int m = matrix.length;
        int n = matrix[0].length;
        int[] res = new int[n * m];

        return res;
    }

    /**
     * Input:
     * [
     * [1, 2, 3, 4],
     * [5, 6, 7, 8],
     * [9,10,11,12]
     * <p>
     * [13,14,15,16]
     * ]
     */
    public List<Integer> spiralOrder(int[][] matrix) {
        if (matrix.length == 0) return new ArrayList<>();
        int rowStart = 0;
        int rowEnd = matrix.length - 1;
        int colStart = 0;
        int colEnd = matrix[0].length - 1;
        List<Integer> res = new ArrayList<>();
        while (rowStart <= rowEnd && colStart <= colEnd) {
            for (int i = colStart; i <= colEnd; i++) {
                int v = matrix[rowStart][i];
                res.add(v);
                System.out.print(v + " ");
            }
            rowStart++;
            for (int i = rowStart; i <= rowEnd; i++) {
                int v = matrix[i][colEnd];
                res.add(v);
                System.out.print(v + " ");
            }
            colEnd--;
            if (rowStart <= rowEnd) {
                for (int i = colEnd; i >= colStart; i--) {
                    int v = matrix[rowEnd][i];
                    res.add(v);
                    System.out.print(v + " ");
                }
                rowEnd--;
            }
            if (colStart <= colEnd) {
                for (int i = rowEnd; i >= rowStart; i--) {
                    int v = matrix[i][colStart];
                    res.add(v);
                    System.out.print(v + " ");
                }
                colStart++;
            }
        }
        return res;
    }

    public int[] plusOne(int[] digits) {
        int rem = 1;
        for (int i = digits.length - 1; i >= 0; i--) {
            if (digits[i] + rem == 10) {
                digits[i] = 0;
            } else {
                digits[i]++;
                break;
            }
        }
        if (digits[0] == 0) {
            digits = Arrays.copyOf(digits, digits.length + 1);
            digits[0] = 1;
        }
//        for (int i = 0; i < digits.length; i++) {
//            System.out.print(digits[i]+" ");
//        }
//        System.out.println();
        return digits;
    }

    public int dominantIndex(int[] nums) {
        if (nums.length == 0) return -1;
        int max = nums[0];
        int maxIndex = 0;
        int max2nd = 0;
        for (int i = 1; i < nums.length; i++) {
            if (nums[i] >= max) {
                int tmp = max;
                max2nd = tmp;
                max = nums[i];
                maxIndex = i;
            } else if (nums[i] > max2nd) {
                max2nd = nums[i];
            }
        }
        return max2nd * 2 <= max ? maxIndex : -1;
    }

    public int pivotIndex(int[] nums) {
        if (nums.length <= 2) return -1;
        int sum = 0;
        for (int num : nums) {
            sum += num;
        }
        int leftSum = 0;
        for (int i = 0; i < nums.length; i++) {
            if (leftSum == sum - leftSum - nums[i]) return i;
            leftSum += nums[i];
        }
        return -1;
    }

    public int[] dailyTemperatures(int[] T) {
        int[] ans = new int[T.length];
        Stack<Integer> stack = new Stack();
        for (int i = T.length - 1; i >= 0; --i) {
            while (!stack.isEmpty() && T[i] >= T[stack.peek()]) stack.pop();
            ans[i] = stack.isEmpty() ? 0 : stack.peek() - i;
            stack.push(i);
        }
        return ans;
    }

    public int[] dailyTemperatures3(int[] T) {
        int[] ans = new int[T.length];
        int[] next = new int[101];
        Arrays.fill(next, Integer.MAX_VALUE);
        for (int i = T.length - 1; i >= 0; --i) {
            int index = Integer.MAX_VALUE;
            for (int j = T[i]; j < next.length; j++) {
                if (next[j] < index) {
                    index = next[j];
                }
            }
            if (index < Integer.MAX_VALUE) {
                ans[i] = index - i;
            }
            next[T[i]] = i;
        }
        return ans;
    }

    //output should be [1, 1, 4, 2, 1, 1, 0, 0].
    //https://leetcode.com/problems/daily-temperatures/description/
    public int[] dailyTemperatures2(int[] temperatures) {
        int[] res = new int[temperatures.length];
        for (int i = 0; i < temperatures.length; i++) {
            int nextWarnDay = 1;
            int j;
            for (j = i + 1; j < temperatures.length; j++) {
                if (temperatures[j] > temperatures[i]) {
                    break;
                }
                nextWarnDay++;
            }
            if (j == temperatures.length)
                res[i] = 0;
            else
                res[i] = nextWarnDay;
        }
        return res;
    }

    public int trap(int[] height) {
        if (height.length <= 2) return 0;
        int max = 0;
        int maxIndex = 0;
        for (int i = 0; i < height.length; i++) {
            if (height[i] > max) {
                max = height[i];
                maxIndex = i;
            }
        }

        int res = 0;
        int l = 0;
        int r = height.length - 1;
        int lastMaxR = 0;
        int lastMaxL = 0;
        while (l <= maxIndex || r >= maxIndex) {
            if (l <= maxIndex) {
                if (height[l] < lastMaxL) {
                    res += lastMaxL - height[l];
                } else {
                    lastMaxL = height[l];
                }
                l++;
            }
            if (r >= maxIndex) {
                if (height[r] < lastMaxR) {
                    res += lastMaxR - height[r];
                } else {
                    lastMaxR = height[r];
                }
                r--;
            }
        }
        return res;
    }

    public int trap2(int[] height) {
        if (height.length <= 2) return 0;
        int max = 0;
        int maxIndex = 0;
        for (int i = 0; i < height.length; i++) {
            if (height[i] > max) {
                max = height[i];
                maxIndex = i;
            }
        }

        int res = 0;
        int lastHeight = 0;
        for (int i = 0; i <= maxIndex; i++) {
            if (height[i] < lastHeight) {
                res += lastHeight - height[i];
            } else {
                lastHeight = height[i];
            }
        }
        lastHeight = 0;
        for (int i = height.length - 1; i >= maxIndex; i--) {
            if (height[i] < lastHeight) {
                res += lastHeight - height[i];
            } else {
                lastHeight = height[i];
            }
        }
        return res;
    }

    //https://leetcode.com/problems/container-with-most-water/description/
    public int maxArea(int[] height) {
        int left = 0;
        int right = height.length - 1;
        int max = 0;
        while (left < right) {
            int minBorder = Math.min(height[left], height[right]);
            max = Math.max(max, (right - left) * minBorder);
            if (height[left] <= height[right]) left++;
            else right--;
        }
        return max;
    }

    //https://leetcode.com/problems/merge-intervals/description/
    public List<Interval> merge(List<Interval> intervals) {
        List<Interval> res = new ArrayList<>();
        if (intervals == null || intervals.isEmpty()) return res;
        Collections.sort(intervals, (a, b) -> Integer.compare(a.start, b.start));
        Interval interval = intervals.get(0);
        for (int i = 1; i < intervals.size(); i++) {
            Interval curr = intervals.get(i);
            if (curr.start <= interval.end) {
                interval.end = Math.max(curr.end, interval.end);
            } else {
                res.add(interval);
                interval = curr;
            }
        }
        res.add(interval);
        return res;
    }

    public List<Integer> partitionLabels2(String S) {
        int[] count = new int[26];
        for (int i = 0; i < S.length(); i++) {
            count[S.charAt(i) - 'a'] = i;
        }
        int last = 0;
        int j = 0;
        List<Integer> res = new ArrayList<>();
        for (int i = 0; i < S.length(); i++) {
            j = Math.max(j, count[S.charAt(i) - 'a']);
            if (i == j) {
                res.add(i - last + 1);
                last = i + 1;
            }
        }
        return res;
    }

    //https://leetcode.com/problems/partition-labels/description/
    //We want to partition this string into as many parts as possible so that each letter appears in at most one part, and return a list of integers representing the size of these parts.
    //outbout [9,7,8]
    public List<Integer> partitionLabels(String S) {
        int[] count = new int[26];
        for (int i = 0; i < S.length(); i++) {
            count[S.charAt(i) - 'a']++;
        }
        Set<Integer> set = new HashSet<>();
        List<Integer> res = new ArrayList<>();
        int c = 0;
        for (int i = 0; i < S.length(); i++) {
            int charAt = S.charAt(i) - 'a';
            c++;
            count[charAt]--;
            set.add(charAt);
            if (count[charAt] == 0) {
                set.remove(charAt);
            }
            if (set.isEmpty()) {
                res.add(c);
                c = 0;
            }
        }
        return res;
    }

    //https://leetcode.com/problems/find-the-duplicate-number/description/
    public int findDuplicate(int[] nums) {
        int slow = nums[0];
        int fast = nums[0];
        do {
            slow = nums[slow];
            fast = nums[nums[fast]];
        } while (slow != fast);

        int start = nums[0];
        while (slow != start) {
            slow = nums[slow];
            start = nums[start];
        }
        return slow;
    }

    //https://leetcode.com/problems/merge-sorted-array/description/
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        int i = m - 1;
        int j = n - 1;
        int curr = nums1.length - 1;
        while (i >= 0 || j >= 0) {
            if (i < 0) {
                nums1[curr--] = nums2[j--];
                continue;
            }
            if (j < 0) {
                nums1[curr--] = nums1[i--];
                continue;
            }
            if (nums1[i] >= nums2[j]) {
                nums1[curr--] = nums1[i--];
            } else {
                nums1[curr--] = nums2[j--];
            }
        }
    }

    //dutch flag
    //https://leetcode.com/problems/sort-colors/description/
    //0 0 1 1 1 1 0 2
    public void sortColors(int[] nums) {
        int s = 0;
        int m = 0;
        int e = nums.length - 1;
        while (m <= e) {
            if (nums[m] == 1) {
                m++;
            } else if (nums[m] == 2) {
                swap(nums, m, e);
                e--;
            } else {
                swap(nums, m, s);
                m++;
                s++;
            }
        }
    }

    public void swap(char[] ar, int i, int j) {
        char tmp = ar[i];
        ar[i] = ar[j];
        ar[j] = tmp;
    }

    //DP medium
    //https://leetcode.com/problems/maximal-square/description/
    public int maximalSquare(char[][] matrix) {
        return 0;
    }

    //https://leetcode.com/problems/find-pivot-index/description/
    //We define the pivot index as the index where the sum of the numbers to the left of the index is equal to the sum of the numbers to the right of the index.
    public int pivotIndex2(int[] nums) {
        if (nums.length <= 2) return -1;
        int sum = 0;
        for (int num : nums) {
            sum += num;
        }
        int leftSum = 0;
        for (int i = 0; i < nums.length; i++) {
            if (leftSum == sum - leftSum - nums[i]) return i;
            leftSum += nums[i];
        }
        return -1;
    }

    //https://leetcode.com/problems/subarray-sum-equals-k/description/
    public int subarraySum(int[] nums, int k) {
        int res = 0;
        Map<Integer, Integer> sumMap = new HashMap<>();
        sumMap.put(0, 1);
        int sum = 0;
        for (int i = 0; i < nums.length; i++) {
            sum += nums[i];
            if (sumMap.containsKey(sum - k)) {
                res += sumMap.get(sum - k);
            }
            sumMap.put(sum, sumMap.getOrDefault(sum, 0) + 1);
        }
        return res;
    }

    public int subarraySum1(int[] nums, int k) {
        int res = 0;
        int sumI = 0;

        for (int i = 0; i <= nums.length; i++) {
            sumI = i == 0 ? 0 : sumI + nums[i - 1];
            int sumJ = sumI;
            for (int j = i + 1; j <= nums.length; j++) {
                sumJ += nums[j - 1];
                if (sumJ - sumI == k) res++;
            }
        }
        return res;
    }

    //https://leetcode.com/problems/task-scheduler/description/
    //medium
    public int leastInterval(char[] tasks, int n) {
        int[] map = new int[26];
        for (char c : tasks)
            map[c - 'A']++;
        Arrays.sort(map);
        int max_val = map[25] - 1, idle_slots = max_val * n;
        for (int i = 24; i >= 0 && map[i] > 0; i--) {
            idle_slots -= Math.min(map[i], max_val);
        }
        return idle_slots > 0 ? idle_slots + tasks.length : tasks.length;
    }

    public int leastInterval3(char[] tasks, int n) {
        int[] count = new int[26];
        for (int i = 0; i < tasks.length; i++) {
            count[tasks[i] - 'A']++;
        }
        int time = 0;
        PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());
        for (int c : count) {
            pq.add(c);
        }
        while (pq.peek() > 0) {
            int c = 0;
            List<Integer> tmpList = new ArrayList<>();
            while (c <= n) {
                if (pq.peek() == 0 && tmpList.isEmpty()) break;
                Integer poll = pq.poll();
                if (poll > 1) {
                    tmpList.add(poll - 1);
                }
                c++;
                time++;
            }
            pq.addAll(tmpList);
        }
        return time;
    }

    public int leastInterval2(char[] tasks, int n) {
        int[] count = new int[26];
        for (int i = 0; i < tasks.length; i++) {
            count[tasks[i] - 'A']++;
        }
        Arrays.sort(count);
        int time = 0;
        while (count[25] != 0) {
            int i = 0;
            while (i <= n) {
                if (count[25] == 0) break;
                if (i < 26 && count[25 - i] > 0) {
                    count[25 - i]--;
                }
                i++;
                time++;
            }
            Arrays.sort(count);
        }
        return time;
    }

    //https://leetcode.com/problems/jump-game-ii/description/
    //hard
    public int jump(int[] nums) {
        if (nums.length == 1) return 0;
        int i = 0;
        int level = 0;
        int max = 0;
        while (i <= max) {
            int currMax = max;
            for (; i <= max; i++) {
                currMax = Math.max(currMax, i + nums[i]);
                if (currMax >= nums.length - 1) return level + 1;
            }
            level++;
            max = Math.max(max, currMax);
        }
        return -1;
    }

    //https://leetcode.com/problems/shortest-unsorted-continuous-subarray/description/
    //easy
    public int findUnsortedSubarray(int[] nums) {
        int[] sorted = Arrays.copyOf(nums, nums.length);
        Arrays.sort(sorted);
        int start = nums.length - 1;
        int end = 0;
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] != sorted[i]) {
                start = Math.min(start, i);
                end = Math.max(end, i);
            }
        }
        return start == nums.length - 1 && end == 0 ? 0 : end - start + 1;
    }

    //https://leetcode.com/problems/island-perimeter/description/
    //easy
    public int islandPerimeter(int[][] grid) {
        if (grid.length == 0) return 0;
        int[] length = new int[1];
        boolean[][] marked = new boolean[grid.length][grid[0].length];
        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[0].length; j++) {
                if (!marked[i][j] && grid[i][j] == 1) {
                    dfsIslandPerimeter(grid, marked, new int[]{i, j}, length);
                }
            }
        }
        return length[0];
    }

    private void dfsIslandPerimeter(int[][] grid, boolean[][] marked, int[] curr, int[] length) {

        List<int[]> neighbours = Arrays.asList(new int[]{1, 0}, new int[]{-1, 0}, new int[]{0, 1}, new int[]{0, -1});
        for (int[] n : neighbours) {
            int[] newEl = new int[]{curr[0] + n[0], curr[1] + n[1]};
            if (isValidIslandPerimeter(grid, marked, newEl)) {
                if (!marked[newEl[0]][newEl[1]]) {
                    marked[newEl[0]][newEl[1]] = true;
                    if (grid[newEl[0]][newEl[1]] == 0) {
                        length[0]++;
                    } else {
                        dfsIslandPerimeter(grid, marked, newEl, length);
                    }
                }

            } else {
                length[0]++;
            }
        }
    }

    private boolean isValidIslandPerimeter(int[][] grid, boolean[][] marked, int[] newEl) {
        return newEl[0] >= 0 && newEl[0] < grid.length && newEl[1] >= 0 && newEl[1] < grid[0].length;
    }

    //https://leetcode.com/problems/max-area-of-island/description/
    //easy
    public int maxAreaOfIsland(int[][] grid) {
        if (grid.length == 0) return 0;
        int maxLengthComponent = 0;
        boolean[][] marked = new boolean[grid.length][grid[0].length];
        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[0].length; j++) {
                if (!marked[i][j] && grid[i][j] == 1) {
                    int[] length = new int[1];
                    length[0]++;
                    int max = dfsMaxAreaOfIsland(grid, marked, new int[]{i, j}, length);
                    maxLengthComponent = Math.max(maxLengthComponent, max);
                }
            }
        }
        return maxLengthComponent;
    }

    private int dfsMaxAreaOfIsland(int[][] grid, boolean[][] marked, int[] curr, int[] length) {
        List<int[]> neighbours = Arrays.asList(new int[]{1, 0}, new int[]{-1, 0}, new int[]{0, 1}, new int[]{0, -1});
        marked[curr[0]][curr[1]] = true;
        for (int[] n : neighbours) {
            int[] el = new int[]{curr[0] + n[0], curr[1] + n[1]};
            if (isValid(grid, marked, el)) {
                marked[el[0]][el[1]] = true;
                length[0]++;
                dfsMaxAreaOfIsland(grid, marked, el, length);
            }
        }
        return length[0];
    }

    private boolean isValid(int[][] grid, boolean[][] marked, int[] el) {
        return el[0] >= 0 && el[0] < grid.length && el[1] >= 0 && el[1] < grid[0].length && grid[el[0]][el[1]] == 1 && !marked[el[0]][el[1]];
    }

    //https://leetcode.com/problems/max-consecutive-ones/description/
    //easy
    public int findMaxConsecutiveOnes(int[] nums) {
        int max = 0;
        int maxSoFar = 0;
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] == 1) maxSoFar++;
            else {
                max = Math.max(max, maxSoFar);
                maxSoFar = 0;
            }
        }
        max = Math.max(max, maxSoFar);
        return max;
    }

    //https://leetcode.com/problems/toeplitz-matrix/description/
    //1234
    //5123
    //9512
    public boolean isToeplitzMatrix(int[][] matrix) {
        if (matrix.length == 0) return false;
        for (int i = 0; i < matrix.length - 1; i++) {
            for (int j = matrix[0].length - 2; j >= 0; j--) {
                if (matrix[i][j] != matrix[i + 1][j + 1]) return false;
            }
        }
        return true;
    }

    //https://leetcode.com/problems/find-all-duplicates-in-an-array/description/
    //medium
    public List<Integer> findDuplicates(int[] nums) {
        List<Integer> res = new ArrayList<>();
        for (int i = 0; i < nums.length; i++) {
            int newIndex = Math.abs(nums[i]) - 1;
            if (nums[newIndex] > 0) {
                nums[newIndex] = -nums[newIndex];
            } else {
                res.add(newIndex + 1);
            }
        }
        return res;
    }

    //https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/description/
    //easy
    public List<Integer> findDisappearedNumbers(int[] nums) {
        for (int i = 0; i < nums.length; i++) {
            int newIndex = Math.abs(nums[i]) - 1;
            if (nums[newIndex] > 0) {
                nums[newIndex] = -nums[newIndex];
            }
        }
        List<Integer> res = new ArrayList();
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] > 0) {
                res.add(i + 1);
            }
        }
        return res;
    }

    //https://leetcode.com/problems/product-of-array-except-self/description/
    //medium
    public int[] productExceptSelf(int[] nums) {
        int[] res = new int[nums.length];
        res[0] = 1;
        int tmpProduct = 1;
        for (int i = 1; i < nums.length; i++) {
            res[i] = nums[i - 1] * tmpProduct;
            tmpProduct *= nums[i - 1];
        }
        tmpProduct = 1;
        for (int i = nums.length - 1; i >= 0; i--) {
            res[i] *= tmpProduct;
            tmpProduct *= nums[i];
        }
        return res;
    }

    //https://leetcode.com/problems/maximum-product-subarray/description/
    //medium
    public int maxProduct(int[] nums) {
        if (nums.length == 0) return 0;
        int max = nums[0];
        int positive = 1;
        int negative = 1;
        for (int i = 0; i < nums.length; i++) {
            int n = nums[i];
            if (n >= 0) {
                positive = Math.max(n, positive * n);
                negative = negative * n;
            } else if (n < 0) {
                int tmp = negative;
                negative = Math.min(n, positive * n);
                positive = tmp * n;
            }
            max = Math.max(max, positive);
            max = Math.max(max, negative);
        }

        return max;
    }

    //https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/
    //Kadane's-Algorithm
    //easy
    public int maxProfit(int[] prices) {
        int min = Integer.MAX_VALUE;
        int maxSoFar = 0;
        for (int i = 0; i < prices.length; i++) {
            if (prices[i] < min) {
                min = prices[i];
            } else if (prices[i] - min > maxSoFar) {
                maxSoFar = prices[i] - min;
            }
        }
        return maxSoFar;
    }

    //easy
    public int maxProfitBruteForce(int[] prices) {
        int maxProfit = 0;
        for (int i = 0; i < prices.length; i++) {
            for (int j = i + 1; j < prices.length; j++) {
                maxProfit = Math.max(prices[j] - prices[i], maxProfit);
            }
        }
        return maxProfit;
    }

    //https://leetcode.com/problems/maximum-subarray/description/
    //Kadane's-Algorithm
    //easy
    //TODO DP solution https://leetcode.com/problems/maximum-subarray/discuss/20193/DP-solution-and-some-thoughts
    public int maxSubArray(int[] nums) {
        if (nums.length == 0) return 0;
        Integer max = nums[0];
        Integer maxSoFar = nums[0];
        for (int i = 1; i < nums.length; i++) {
            if (nums[i] > maxSoFar + nums[i]) {
                maxSoFar = nums[i];
            } else {
                maxSoFar += nums[i];
            }
            max = Math.max(max, maxSoFar);
        }
        return max;
    }

    //https://leetcode.com/problems/degree-of-an-array/description/
    //easy
    public int findShortestSubArray(int[] nums) {
        Map<Integer, Integer> left = new HashMap<>();
        Map<Integer, Integer> right = new HashMap<>();
        Map<Integer, Integer> count = new HashMap<>();

        for (int i = 0; i < nums.length; i++) {
            int el = nums[i];
            if (left.get(el) == null) left.put(el, i);
            right.put(el, i);
            count.put(el, count.getOrDefault(el, 0) + 1);
        }

        int degree = Collections.max(count.values());
        Integer result = nums.length;
        for (int i = 0; i < nums.length; i++) {
            if (count.get(nums[i]) == degree) {
                result = Math.min(result, right.get(nums[i]) - left.get(nums[i]) + 1);
            }
        }
        return result;
    }

    public interface NestedInteger {

        // @return true if this NestedInteger holds a single integer, rather than a nested list.
        public boolean isInteger();

        // @return the single integer that this NestedInteger holds, if it holds a single integer
        // Return null if this NestedInteger holds a nested list
        public Integer getInteger();

        // @return the nested list that this NestedInteger holds, if it holds a nested list
        // Return null if this NestedInteger holds a single integer
        public List<NestedInteger> getList();
    }

    static class MyHashMap {

        private int buckets = 1000;
        private int itemsPerBucket = 1001;
        private Integer[][] table;

        /**
         * Initialize your data structure here.
         */
        public MyHashMap() {
            table = new Integer[buckets][];
        }

        public int hash(int key) {
            return key % buckets;
        }

        public int pos(int key) {
            return key / buckets;
        }

        public void put(int key, int value) {
            int hashkey = hash(key);

            if (table[hashkey] == null) {
                table[hashkey] = new Integer[itemsPerBucket];
            }
            table[hashkey][pos(key)] = value;
        }

        public void remove(int key) {
            int hashkey = hash(key);

            if (table[hashkey] != null)
                table[hashkey][pos(key)] = null;
        }

        /**
         * Returns true if this set did not already contain the specified element
         */
        public int get(int key) {
            int hashkey = hash(key);
            if (table[hashkey] != null && table[hashkey][pos(key)] != null) {
                return table[hashkey][pos(key)];
            }
            return -1;
        }
    }

    public class TreeLinkNode {
        int val;
        TreeLinkNode left, right, next;

        TreeLinkNode(int x) {
            val = x;
        }
    }

    class Pair<K, V> {
        K key;
        V value;

        public Pair(K key, V value) {
            this.key = key;
            this.value = value;
        }
    }

    public class NestedIterator implements Iterator<Integer> {
        Iterator<Integer> iterator;
        Stack<NestedInteger> stack;

        public NestedIterator(List<NestedInteger> nestedList) {
            stack = new Stack();
            init(stack, nestedList);
        }

        private void init(Stack<NestedInteger> stack, List<NestedInteger> nestedList) {
            for (int i = nestedList.size() - 1; i >= 0; i--) {
                stack.add(nestedList.get(i));
            }
        }

        @Override
        public Integer next() {
            if (hasNext())
                return stack.pop().getInteger();
            return null;
        }

        @Override
        public boolean hasNext() {
            while (!stack.isEmpty()) {
                NestedInteger peek = stack.peek();
                if (peek.isInteger()) {
                    return true;
                } else {
                    NestedInteger pop = stack.pop();
                    for (int i = pop.getList().size() - 1; i >= 0; i--) {
                        stack.push(pop.getList().get(i));
                    }
                }
            }
            return false;
        }
    }

    class Interval {
        int start;
        int end;

        Interval() {
            start = 0;
            end = 0;
        }

        Interval(int s, int e) {
            start = s;
            end = e;
        }

        @Override
        public String toString() {
            return "Interval{" +
                    "start=" + start +
                    ", end=" + end +
                    '}';
        }
    }


}

